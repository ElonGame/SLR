SetRenderer("method": "PT", "samples": 512);
SetRenderSettings("width": 1024, "height": 1024, "brightness": 4.0);

CBNode = Load3DModel("models/Cornell_box_RB.assbin");
    lightNode = CreateNode();
    SetTransform(lightNode, Translate(0.0, 0.999, 0.0));
        diffuseCol = Spectrum(0.9, 0.9, 0.9);
        diffuseTex = SpectrumTexture(diffuseCol);
        scatterMat = CreateMatte(diffuseTex);
        difLightCol = Spectrum("ID": "D65");
        difLightTex = SpectrumTexture(difLightCol);
        emitterMat = CreateDiffuseEmitter(difLightTex);
        surfMat = CreateEmitterSurfaceMaterial(scatterMat, emitterMat);

        lightMesh = CreateMesh(
            (
            ((-0.25, 0, -0.25), (0, -1, 0), (1, 0, 0), (0, 0)), 
            (( 0.25, 0, -0.25), (0, -1, 0), (1, 0, 0), (1, 0)),
            (( 0.25, 0,  0.25), (0, -1, 0), (1, 0, 0), (1, 1)),
            ((-0.25, 0,  0.25), (0, -1, 0), (1, 0, 0), (0, 1))
            ),
            (
            ((0, 1, 2), surfMat), 
            ((0, 2, 3), surfMat)
            )
            );
        AddChild(lightNode, lightMesh);
    AddChild(CBNode, lightNode);
AddChild(root, CBNode);
SetTransform(CBNode, RotateY(-1.5707963268));

mats = (,);
for (i = 0; i < 24; ++i) {
    sp = Spectrum("ID": "ColorChecker", i);
    difTex = SpectrumTexture(sp);
    scatterMat = CreateMatte(difTex);
    //AddItem(mats, scatterMat);
}

/*
Construct ColorChecker
TriangleMeshNodeRef mesh = createShared<TriangleMeshNode>();

std::vector<SurfaceMaterialRef> mats;
for (int i = 0; i < 24; ++i) {
    InputSpectrumRef sp = createInputSpectrum(SpectrumType::Reflectance, ColorChecker::MinWavelength, ColorChecker::MaxWavelength,
                                              ColorChecker::Spectra[i], ColorChecker::NumSamples);
    SpectrumTextureRef diffuseTex = createShared<ConstantSpectrumTexture>(sp);
    SurfaceMaterialRef scatterMat = SurfaceMaterial::createMatte(diffuseTex, nullptr);
    mats.push_back(scatterMat);
}

for (int i = 0; i < 24; ++i) {
    Matrix4x4 transform = rotateY(float(M_PI / 2)) * translate(0.0f, 0.0f, -0.999f) * scale(0.9f / 3.0f) * translate(-3.0f + float(i % 6), 1.0f - float(i / 6), 0.0f);
    mesh->addVertex(Vertex(transform * Point3D(0.0f, 0.0f, 0.0f), transform * Normal3D(0, -1, 0), transform * Tangent3D(1, 0, 0), TexCoord2D(0, 0)));
    mesh->addVertex(Vertex(transform * Point3D(1.0f, 0.0f, 0.0f), transform * Normal3D(0, -1, 0), transform * Tangent3D(1, 0, 0), TexCoord2D(1, 0)));
    mesh->addVertex(Vertex(transform * Point3D(1.0f, 1.0f, 0.0f), transform * Normal3D(0, -1, 0), transform * Tangent3D(1, 0, 0), TexCoord2D(1, 1)));
    mesh->addVertex(Vertex(transform * Point3D(0.0f, 1.0f, 0.0f), transform * Normal3D(0, -1, 0), transform * Tangent3D(1, 0, 0), TexCoord2D(0, 1)));
    
    uint32_t idxBase = 4 * i;
    mesh->addTriangle(idxBase + 0, idxBase + 1, idxBase + 2, mats[i]);
    mesh->addTriangle(idxBase + 0, idxBase + 2, idxBase + 3, mats[i]);
}

CBNode->addChildNode(mesh);
*/

pikachuNode = Load3DModel("models/Pikachu_corrected.assbin");
SetTransform(pikachuNode, Translate(0, -1, 0) * RotateY(2.3561944902) * Scale(0.2));
AddChild(CBNode, pikachuNode);

cameraNode = CreateNode();
    camera = CreatePerspectiveCamera("aspect": 1.0, "fovY": 0.5235987756, "radius": 0.1, 
                                     "imgDist": 1.0, "objDist": 6.0);
    AddChild(cameraNode, camera);
SetTransform(cameraNode, Translate(0, 0, 5) * RotateY(-3.1415926536));

AddChild(root, cameraNode);
SetTransform(root, RotateY(-1.5707963268));
